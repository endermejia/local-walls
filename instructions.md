# Database Updates for Granular User Blocking

Run the following SQL commands in your Supabase SQL Editor to implement the granular blocking feature.

## 1. Create/Update `user_blocks` table

If the table doesn't exist:
```sql
create table if not exists public.user_blocks (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  blocker_id uuid references auth.users not null,
  blocked_id uuid references auth.users not null,
  block_messages boolean default false not null,
  block_ascents boolean default false not null,
  unique (blocker_id, blocked_id)
);

alter table public.user_blocks enable row level security;
```

If the table already exists (from previous step), run this to add columns:
```sql
alter table public.user_blocks
add column if not exists block_messages boolean default false not null,
add column if not exists block_ascents boolean default false not null;
```

## 2. RLS Policies for `user_blocks`

Allow users to manage their own blocks.

```sql
create policy "Users can see blocks where they are the blocker"
on public.user_blocks for select
using (auth.uid() = blocker_id);

create policy "Users can insert their own blocks"
on public.user_blocks for insert
with check (auth.uid() = blocker_id);

create policy "Users can update their own blocks"
on public.user_blocks for update
using (auth.uid() = blocker_id);

create policy "Users can delete their own blocks"
on public.user_blocks for delete
using (auth.uid() = blocker_id);
```

## 3. Update Chat Messages Policy

Modify the policy to prevent *sending* messages if `block_messages` is true (mutual check). Reading is allowed for history.

```sql
-- Drop the existing policies
drop policy if exists "participants_can_read" on public.chat_messages;
drop policy if exists "participants_can_insert" on public.chat_messages;

-- Create the new policies
create policy "participants_can_read"
on public.chat_messages for select
using (
  is_chat_participant(room_id)
);

create policy "participants_can_insert"
on public.chat_messages for insert
with check (
  is_chat_participant(room_id)
  and (auth.uid() = sender_id)
  and not exists (
    select 1 from user_blocks
    where (
      (blocker_id = auth.uid() and blocked_id = chat_messages.sender_id) -- Should be recipient, but sender_id is me. We need to check relation with other participant.
      -- However, chat_messages doesn't have recipient_id directly, it has room_id.
      -- Ideally, we check if ANY other participant in the room has blocked me or I have blocked them.
      -- For 1:1 chats, this logic holds. For group chats, it might be complex.
      -- Assuming 1:1 for now or simplified logic:
      -- We need to check if there is a block between auth.uid() and ANY other participant in the room.
      -- But Supabase policies on insert can be tricky with joins.
      -- Simplified check: Check if I am blocked by anyone in the room or I blocked anyone in the room.
      -- Wait, the standard "participants_can_insert" was: (is_chat_participant(room_id) AND (( SELECT auth.uid() AS uid) = sender_id))

      -- Let's stick to the request: "al bloquear los mensajes con un usuario, solo debe impedir insertar nuevos mensajes"
      -- This implies checking the block status relative to the *other* user in the chat room.
      -- Since we don't have the other user ID easily available in a single row check without a join on chat_participants...

      -- Correct approach for 1:1 rooms (assuming most are):
      exists (
        select 1 from chat_participants cp
        where cp.room_id = chat_messages.room_id
        and cp.user_id != auth.uid()
        and exists (
            select 1 from user_blocks ub
            where (ub.blocker_id = auth.uid() and ub.blocked_id = cp.user_id and ub.block_messages = true)
               or (ub.blocker_id = cp.user_id and ub.blocked_id = auth.uid() and ub.block_messages = true)
        )
      )
    )
  )
);
-- Wait, the NOT EXISTS above was negating the whole block.
-- Let's rewrite for clarity.
-- INSERT is allowed IF:
-- 1. I am a participant.
-- 2. I am the sender.
-- 3. There is NO block (message blocking) between me and the other participant(s).

create policy "participants_can_insert"
on public.chat_messages for insert
with check (
  is_chat_participant(room_id)
  and (auth.uid() = sender_id)
  and not exists (
    select 1 from chat_participants cp
    join user_blocks ub on (
         (ub.blocker_id = auth.uid() and ub.blocked_id = cp.user_id)
      or (ub.blocker_id = cp.user_id and ub.blocked_id = auth.uid())
    )
    where cp.room_id = chat_messages.room_id
    and cp.user_id != auth.uid()
    and ub.block_messages = true
  )
);
```

## 4. Update Route Ascents Policy

Modify the policy to hide ascents if `block_ascents` is true (mutual check).

```sql
-- Drop the existing policy
drop policy if exists "auth_can_read" on public.route_ascents;

-- Create the new policy
create policy "auth_can_read"
on public.route_ascents for select
using (
  (auth.uid() = user_id) -- Always see own ascents
  or
  (
    is_profile_public(user_id) -- Check public profile
    and not exists (
      select 1 from user_blocks
      where (
        (blocker_id = auth.uid() and blocked_id = route_ascents.user_id)
        or
        (blocker_id = route_ascents.user_id and blocked_id = auth.uid())
      )
      and block_ascents = true
    )
  )
);
```
